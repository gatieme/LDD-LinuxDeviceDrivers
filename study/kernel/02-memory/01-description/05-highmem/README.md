 服务器体系与共享存储器架构
=======

| 日期 | 内核版本 | 架构| 作者 | GitHub| CSDN |
| ------- |:-------:|:-------:|:-------:|:-------:|:-------:|
| 2016-06-14 | [Linux-4.7](http://lxr.free-electrons.com/source/?v=4.7) | X86 & arm | [gatieme](http://blog.csdn.net/gatieme) | [LinuxDeviceDrivers](https://github.com/gatieme/LDD-LinuxDeviceDrivers) | [Linux内存管理](http://blog.csdn.net/gatieme/article/category/6225543) |



#1	前景回顾
-------


前面我们讲到[服务器体系(SMP, NUMA, MPP)与共享存储器架构(UMA和NUMA)](http://blog.csdn.net/gatieme/article/details/52098615)


#1.1	UMA和NUMA两种模型
-------

共享存储型多处理机有两种模型

*	均匀存储器存取（Uniform-Memory-Access，简称UMA）模型


*	非均匀存储器存取（Nonuniform-Memory-Access，简称NUMA）模型

**UMA模型**

物理存储器被所有处理机均匀共享。所有处理机对所有存储字具有相同的存取时间，这就是为什么称它为均匀存储器存取的原因。每台处理机可以有私用高速缓存,外围设备也以一定形式共享。

**NUMA模型**

NUMA模式下，处理器被划分成多个"节点"（node）， 每个节点被分配有的本地存储器空间。 所有节点中的处理器都可以访问全部的系统物理存储器，但是访问本节点内的存储器所需要的时间，比访问某些远程节点内的存储器所花的时间要少得多。


##1.2	Linux如何描述物理内存
-------

Linux把物理内存划分为三个层次来管理

| 层次 | 描述 |
|:----:|:----:|
| 存储节点(Node) |  CPU被划分为多个节点(node), 内存则被分簇, 每个CPU对应一个本地物理内存, 即一个CPU-node对应一个内存簇bank，即每个内存簇被认为是一个节点 |
| 管理区(Zone)   | 每个物理内存节点node被划分为多个内存管理区域, 用于表示不同范围的内存, 内核可以使用不同的映射方式映射物理内存 |
| 页面(Page) 	   |	内存被细分为多个页面帧, 页面是最基本的页面分配的单位　｜



*	首先, 内存被划分为结点. 每个节点关联到系统中的一个处理器, 内核中表示为`pg_data_t`的实例. 系统中每个节点被链接到一个以NULL结尾的`pgdat_list`链表中<而其中的每个节点利用`pg_data_tnode_next`字段链接到下一节．而对于PC这种UMA结构的机器来说, 只使用了一个成为contig_page_data的静态pg_data_t结构.

*	接着各个节点又被划分为内存管理区域, 一个管理区域通过struct zone_struct描述, 其被定义为zone_t, 用以表示内存的某个范围, 低端范围的16MB被描述为ZONE_DMA, 某些工业标准体系结构中的(ISA)设备需要用到它, 然后是可直接映射到内核的普通内存域ZONE_NORMAL,最后是超出了内核段的物理地址域ZONE_HIGHMEM, 被称为高端内存.　是系统中预留的可用内存空间, 不能被内核直接映射.




##1.3	典型架构(x86)上内存区域划分
-------


对于x86机器，管理区(内存区域)类型如下分布

| 类型 | 区域 |
| :------- | ----: |
| ZONE_DMA | 0~15MB |
| ZONE_NORMAL | 16MB~895MB |
| ZONE_HIGHMEM | 896MB~物理内存结束 |

而由于32位系统中, Linux内核虚拟地址空间只有1G, 而0~895M这个986MB被用于DMA和直接映射, 剩余的物理内存被成为高端内存. 那内核是如何借助剩余128MB高端内存地址空间是如何实现访问可以所有物理内存？

当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑地址空间，借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存

>关于高端内存的内容, 我们后面会专门抽出一章进行讲解

因此, 传统和X86_32位系统中, 前16M划分给ZONE_DMA, 该区域包含的页框可以由老式的基于ISAS的设备通过DMA使用"直接内存访问(DMA)", ZONE_DMA和ZONE_NORMAL区域包含了内存的常规页框, 通过把他们线性的映射到现行地址的第4个GB, 内核就可以直接进行访问, 相反ZONE_HIGHME包含的内存页不能由内核直接访问, 尽管他们也线性地映射到了现行地址空间的第4个GB. 在64位体系结构中, 线性地址空间的大小远远好过了系统的实际物理地址, 内核可知直接将所有的物理内存映射到线性地址空间, 因此64位体系结构上ZONE_HIGHMEM区域总是空的.




#2	内核空间和用户空间
-------



>传统32bit cpu上, 最大寻址的物理内存空间是4GByte, 线性地址空间也是4GByte的情况下, linux内存管理会 : 应用程序3G + 内核 1G这样划分



##2.1	把内核空间和用户空间分开
-------



过去，CPU的地址总线只有32位， 32的地址总线无论是从逻辑上还是从物理上都只能描述4G的地址空间（232=4Gbit），在物理上理论上最多拥有4G内存（除了IO地址空间，实际内存容量小于4G），逻辑空间也只能描述4G的线性地址空间。

为了合理的利用逻辑4G空间，Linux采用了3：1的策略，即内核占用1G的线性地址空间，用户占用3G的线性地址空间。所以用户进程的地址范围从0~3G，内核地址范围从3G~4G，也就是说，内核空间只有1G的逻辑线性地址空间。

把内核空间和用户空间分开是方便为了MMU映射
如果内核空间和用户空间都是0~4G范围的话，
那么当从用户态切入到内核态时(系统调用或者中断)，就必须要切换MMU映射 
(程序里一个逻辑地址在用户态和内核态肯定被映射到不同的物理地址上)
这种切换代价是很大，但是用户态/内核态的切换却是非常频繁的。
而且从技术上你根本没法切换，因为这个时候程序内的任何地址都被映射给用户进程，你根本没法取到内核数据。
就算进入内核态时你切换MMU映射，如果这个时候你要读写用户进程的数据怎么办呢？
难道又去映射MMU？
把0~3G分给用户进程、3~4G就能很好的解决这个问题



这样一来就是你用户程序里的所有变量和函数的 逻辑地址都是介于0~3G的

内核代码里所有变量和函数的逻辑地址都是介于3~4G的

所谓用户空间和内核空间，从cpu角度来说，只是运行的级别不一样，是否处于特权级别而已

逻辑地址到物理地址的MMU映射是不变的。

不管是用户态还是内核态，最终都是通过MMU映射到你的物理上的896M内存

mmap就可以映射物理内存到用户空间，你可以清楚的看到同一块物理内在用户态和内核态的不同逻辑地址

两个不同的逻辑地址(一个介于0~3G，一个介于3-4G) 通过MMU映射到同一块物理内存


##2.2	linux为什么把内核映射到3G-4G这个地址呢
-------



>假如linux把内核映射到0-1G的空间，其他进程共享1-4G的空间不可以吗？



这个技术上也是可以的，而且不难实现。为什么不采用估计有历史原因吧 

毕竟cpu和程序出来的年代比MMU早多了

没有MMU的年代里，对于x86，逻辑地址就是物理地址。物理地址从0开始，那么程序的逻辑地址从一开始也是从0开始的



对于任何用户进程，0~3G的映射都是不同的，但是所有用户进程3~4G的映射都是相同的

一个进程从用户态切入到内核态，MMU映射不需要变。你能很方便取得内核数据和用户进程的数据 



##2.2	应用程序线性地址和动态内存分配
-------

应用程序能使用的最大线性地址就是3G, 根据linux应用的分区方法:

```cpp
---------------------------- 4G

内核空间

---------------------------- 3G

栈 - 向下增长

map - 固定映射

堆 - 向上增长

数据段

代码段

---------------------------- 0G
```


应用层的动态内存分配, 比如malloc, 一般使用的是dlmalloc库, 具体见:http://opendevkit.com/?e=56

所以, 低端内核和高端内存是内核的概念, 跟应用程序没有直接关系.



如果Linux物理内存小于1G的空间，通常内核把物理内存与其地址空间做了线性映射，也就是一一映射，这样可以提高访问速度。但是，当Linux物理内存超过1G时，线性访问机制就不够用了，因为只能有1G的内存可以被映射，剩余的物理内存无法被内核管理，所以，为了解决这一问题，Linux把内核地址分为线性区和非线性区两部分，线性区规定最大为896M，剩下的128M为非线性区。从而，线性区映射的物理内存成为低端内存，剩下的物理内存被成为高端内存。与线性区不同，非线性区不会提前进行内存映射，而是在使用时动态映射。



#2.3	高端内存和低端内存的划分
-------

那么既然内核态的地址范围只有1G的，如果你有4G物理上的内存，显然你没法一次性全部映射所有的物理内存到内核态地址。
所有才有了高端内存。低896M的内存做直接映射，剩下的128M 根据需要动态的映射到剩下的物理内存。

64位的内核就可以很好的解决这个问题，但是64位系统不是意味着就有64根地址线。因为没必要，实际不需要那么大内存。
假设你有38位地址线，可以寻址到2048G的内存，也按照3:1划分，那么内核态就有512G范围，你的512G物理内存可以一次性的全部映射到内核空间，根本不需要高端内存


Linux物理内存空间分为DMA内存区(DMA Zone)、低端内存区(Normal Zone)与高端内存区(Highmem Zone)三部分。DMA Zone通常很小，只有几十M，低端内存区与高端内存区的划分来源于Linux内核空间大小的限制。



##2.4	低端内存和高端内存
-------

我们知道, 内核空间有1G的线性地址可用, 内核会根据物理内存情况, 直接映射一部分物理内存到内核线性地址上, 这部分内存就是低端内存, 物理地址和虚拟地址(线性地址)只有一个偏移. 这样方便管理, 而且效率高.

当物理内存大于1G的时候, 内核是不能完全用低端内存管理全部物理内存的, 所以低端内存剩下的部分就是高端内存了, 高端内存没有直接映射的, 是动态映射到内核空间的.

一般 128M给高端内存分配用, 因为很少, 所以不用要赶紧释放掉

64bit的时候, 就不存在低端内存和高端内存的概念了, 因为空间很大都可以直接管理了.


##2.5	例子
-------



假设物理内存为2G，则低段的896M为低端内存，通过线性映射给内核使用，其他的1128M物理内存为高端内存，可以被内核的非线性区使用。由于要使用128M非线性区来管理超过1G的高端内存，所以通常都不会映射，只有使用时才使kmap映射，使用完后要尽快用kunmap释放。

对于物理内存为1G的内核，系统不会真的分配896M给线性空间，896M是最大限制

下面是一个1.5G物理内存linux系统的真实分配情况，只有721M分配给了低端内存区，如果是1G的linxu系统，分配的就更少了。

| 区域 | 大小 |
|:-----:|:-----:|
| MemTotal | 1547MB |
| HighTotal  | 825MB   |
| LowTotal   | 721MB   |

申请高端内存时，如果高端内存不够了，linux也会去低端内存区申请，反之则不行。





#3	Linux内核高端内存的由来
-------


##3.1	为什么需要高端内存？
-------


高端内存是指物理地址大于 896M 的内存。对于这样的内存，无法在“内核直接映射空间”进行映射。

内核空间只有1GB线性地址，如果使用大于1GB的物理内存就没法直接映射到内核线性空间了。

当系统中的内存大于896MB时，把内核线性空间分为两部分，内核中低于896MB线性地址空间直接映射到低896MB的物理地址空间；高于896MB的128MB内核线性空间用于动态映射ZONE_HIGHMEM内存区域（即物理地址高于896MB的物理空间）。


因为“内核直接映射空间”最多只能从 3G 到 4G，只能直接映射 1G 物理内存，对于大于 1G 的物理内存，无能为力。
实际上，“内核直接映射空间”也达不到 1G， 还得留点线性空间给“内核动态映射空间” 呢。
因此，Linux 规定“内核直接映射空间” 最多映射 896M 物理内存。

对于高端内存，可以通过 alloc_page() 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行（为什么？想想 MMU 是如何访问物理内存的），也就是说，我们需要为高端内存对应的 page 找一个线性空间，这个过程称为高端内存映射。

##3.2	高端内存
-------

在传统的x86_32系统中, 当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址一对一的映射，如逻辑地址0xc0000003对应的物理地址为0×3，0xc0000004对应的物理地址为0×4，… …，

逻辑地址与物理地址对应的关系为

>物理地址 = 逻辑地址 – 0xC0000000

这是内核地址空间的地址转换关系，注意内核的虚拟地址在“高端”，但是ta映射的物理内存地址在低端。

```cpp
逻辑地址	物理内存地址
0xc0000000	0×0
0xc0000001	0×1
0xc0000002	0×2
0xc0000003	0×3
…	…
0xe0000000	0×20000000
…	…
0xffffffff	0×40000000 ??
```

假设按照上述简单的地址映射关系，那么内核逻辑地址空间访问为0xc0000000 ~ 0xffffffff，那么对应的物理内存范围就为0×0 ~ 0×40000000，即只能访问1G物理内存。若机器中安装8G物理内存，那么内核就只能访问前1G物理内存，后面7G物理内存将会无法访问，因为内核 的地址空间已经全部映射到物理内存地址范围0×0 ~ 0×40000000。即使安装了8G物理内存，那么物理地址为0×40000001的内存，内核该怎么去访问呢？代码中必须要有内存逻辑地址 的，0xc0000000 ~ 0xffffffff的地址空间已经被用完了，所以无法访问物理地址0×40000000以后的内存。

显 然不能将内核地址空间0xc0000000 ~ 0xfffffff全部用来简单的地址映射。因此x86架构中将内核地址空间划分三部分：ZONE_DMA、ZONE_NORMAL和 ZONE_HIGHMEM。ZONE_HIGHMEM即为高端内存，这就是内存高端内存概念的由来。


在x86结构中，三种类型的区域（从3G开始计算）如下：

| 区域 | 位置 |
|:-----:|:-----:|
| ZONE_DMA | 内存开始的16MB |
| ZONE_NORMAL | 16MB~896MB |
| ZONE_HIGHMEM | 896MB ~ 结束(1G) |

 

##3.3	Linux内核高端内存的理解
-------

前 面我们解释了高端内存的由来。 Linux将内核地址空间划分为三部分ZONE_DMA、ZONE_NORMAL和ZONE_HIGHMEM，高端内存HIGH_MEM地址空间范围为 0xF8000000 ~ 0xFFFFFFFF（896MB～1024MB）。那么如内核是如何借助128MB高端内存地址空间是如何实现访问可以所有物理内存？

当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑地址空间，借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。如下图。

例 如内核想访问2G开始的一段大小为1MB的物理内存，即物理地址范围为0×80000000 ~ 0x800FFFFF。访问之前先找到一段1MB大小的空闲地址空间，假设找到的空闲地址空间为0xF8700000 ~ 0xF87FFFFF，用这1MB的逻辑地址空间映射到物理地址空间0×80000000 ~ 0x800FFFFF的内存。映射关系如下：

```cpp
逻辑地址	物理内存地址
0xF8700000	0×80000000
0xF8700001	0×80000001
0xF8700002	0×80000002
…	…
0xF87FFFFF	0x800FFFFF
```

当内核访问完0×80000000 ~ 0x800FFFFF物理内存后，就将0xF8700000 ~ 0xF87FFFFF内核线性空间释放。这样其他进程或代码也可以使用0xF8700000 ~ 0xF87FFFFF这段地址访问其他物理内存。

从上面的描述，我们可以知道**高端内存的最基本思想**, 借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。

看到这里，不禁有人会问：万一有内核进程或模块一直占用某段逻辑地址空间不释放，怎么办？若真的出现的这种情况，则内核的高端内存地址空间越来越紧张，若都被占用不释放，则没有建立映射到物理内存都无法访问了。



##4	Linux内核高端内存的划分与映射

-------


内核将高端内存划分为3部分：

*    VMALLOC_START~VMALLOC_END

*    KMAP_BASE~FIXADDR_START

*    FIXADDR_START~4G



对 于高端内存，可以通过 alloc_page() 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行（为什么？想想 MMU 是如何访问物理内存的），也就是说，我们需要为高端内存对应的 page 找一个线性空间，这个过程称为高端内存映射。




对应高端内存的3部分，高端内存映射有三种方式：


##4.1	映射到”内核动态映射空间”（noncontiguous memory allocation）
-------



这种方式很简单，因为通过 vmalloc() ，在”内核动态映射空间”申请内存的时候，就可能从高端内存获得页面（参看 vmalloc 的实现），因此说高端内存有可能映射到”内核动态映射空间”中。


##4.2	持久内核映射（permanent kernel mapping）
-------



如果是通过 alloc_page() 获得了高端内存对应的 page，如何给它找个线性空间？
内核专门为此留出一块线性空间，从 PKMAP_BASE 到 FIXADDR_START ，用于映射高端内存。在 2.6内核上，这个地址范围是 4G-8M 到 4G-4M 之间。这个空间起叫”内核永久映射空间”或者”永久内核映射空间”。这个空间和其它空间使用同样的页目录表，对于内核来说，就是 swapper_pg_dir，对普通进程来说，通过 CR3 寄存器指向。通常情况下，这个空间是 4M 大小，因此仅仅需要一个页表即可，内核通过来 pkmap_page_table 寻找这个页表。通过 kmap()，可以把一个 page 映射到这个空间来。由于这个空间是 4M 大小，最多能同时映射 1024 个 page。因此，对于不使用的的 page，及应该时从这个空间释放掉（也就是解除映射关系），通过 kunmap() ，可以把一个 page 对应的线性地址从这个空间释放出来。



##4.3	临时映射（temporary kernel mapping）
-------


内核在 FIXADDR_START 到 FIXADDR_TOP 之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。

这块空间具有如下特点：

1.	每个 CPU 占用一块空间

2.	在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个 page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的 km_type 中。

当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。通过 kmap_atomic() 可实现临时映射。




#5	页框管理
-------


##5.1	页框管理
-------

Linux采用4KB页框大小作为标准的内存分配单元。内核必须记录每个页框的状态，这种状态信息保存在一个类型为page的页描述符中，所有的页描述存放在mem_map中

virt_to_page(addr)产生线性地址对应的页描述符地址。pfn_to_page(pfn)产生对应页框号的页描述符地址。

在页框描述符中，几个关键的字段我认为：flags、_count、_mapcount。
由于CPU对内存的非一致性访问，系统的物理内存被划分为几个节点(每个节点的描述符为pg_data_t)，每个节点的物理内存又可以分为3个管理区：ZONE_DMA(低于16M的页框地址)，ZONE_NORMAL(16MB-896MB的页框地址)和ZONE_HIGHMEM(高于896MB的页框地址)。

每个管理区又有自己的描述符，描述了该管理区空闲的页框，保留页数目等。每个页描述符都有到内存节点和到节点管理区的连接（被放在flag的高位字段）。
内核调用一个内存分配函数时，必须指明请求页框所在的管理区，内核通常指明它愿意使用哪个管理区。



##5.2	保留的页框池
-------

如果有足够的空闲内存可用、请求就会被立刻满足。否则，必须回收一些内存，并且将发出请求的内核控制路径阻塞，直到有内存被释放。但是有些控制路径不能被阻塞，例如一些内核路径产生一些原子内存分配请求。尽管无法保证一个原子内存分配请求不失败，但是内核会减少这中概率。为了做到如此，内核采取的方案为原子内存分配请求保留一个页框池，只有在内存不足时才使用。页框池有ZONE_DMA和ZONE_NORMAL两个区贡献出一些页框。
常用的请求页框和释放页框函数：
alloc_pages(gfp_mask, order): 获得连续的页框，返回页描述符地址，是其他类型内存分配的基础。
__get_free_pages(gfp_mask, order): 获得连续的页框，返回页框对应的线性地址。线性地址与物理地址是内核直接映射方式。不能用于大于896M的高端内存。
__free_pages(page,order)；
__free_pages(addr,order);



#6	常见问题
-------

##6.1	用户空间（进程）是否有高端内存概念？
-------


用户进程没有高端内存概念。只有在内核空间才存在高端内存。用户进程最多只可以访问3G物理内存，而内核进程可以访问所有物理内存。

 

##6.2	64位内核中有高端内存吗？
-------


目前现实中，64位Linux内核不存在高端内存，因为64位内核可以支持超过512GB内存。若机器安装的物理内存超过内核地址空间范围，就会存在高端内存。



##6.3	用户进程能访问多少物理内存？内核代码能访问多少物理内存？
-------


32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。

64位系统用户进程最大可以访问超过512GB，内核代码可以访问所有物理内存。



##6.4	高端内存和物理地址、逻辑地址、线性地址的关系？
-------


高端内存只和逻辑地址有关系，和逻辑地址、物理地址没有直接关系。



##6.5	为什么不把所有的地址空间都分配给内核？
-------


若把所有地址空间都给内存，那么用户进程怎么使用内存？怎么保证内核使用内存和用户进程不起冲突？


1.	让我们忽略Linux对段式内存映射的支持。 在保护模式下，我们知道无论CPU运行于用户态还是核心态，CPU执行程序所访问的地址都是虚拟地址，MMU 必须通过读取控制寄存器CR3中的值作为当前页面目录的指针，进而根据分页内存映射机制（参看相关文档）将该虚拟地址转换为真正的物理地址才能让CPU真 正的访问到物理地址。

2.	对于32位的Linux，其每一个进程都有4G的寻址空间，但当一个进程访问其虚拟内存空间中的某个地址时又是怎样实现不与其它进程的虚拟空间混淆 的呢？每个进程都有其自身的页面目录PGD，Linux将该目录的指针存放在与进程对应的内存结构task_struct.(struct mm_struct)mm->pgd中。每当一个进程被调度（schedule()）即将进入运行态时，Linux内核都要用该进程的PGD指针设 置CR3（switch_mm()）。

3.	当创建一个新的进程时，都要为新进程创建一个新的页面目录PGD，并从内核的页面目录swapper_pg_dir中复制内核区间页面目录项至新建进程页面目录PGD的相应位置，具体过程如下：
do_fork() --> copy_mm() --> mm_init() --> pgd_alloc() --> set_pgd_fast() --> get_pgd_slow() --> memcpy(&PGD + USER_PTRS_PER_PGD, swapper_pg_dir + USER_PTRS_PER_PGD, (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t))
这样一来，每个进程的页面目录就分成了两部分，第一部分为“用户空间”，用来映射其整个进程空间（0x0000 0000－0xBFFF FFFF）即3G字节的虚拟地址；第二部分为“系统空间”，用来映射（0xC000 0000－0xFFFF FFFF）1G字节的虚拟地址。可以看出Linux系统中每个进程的页面目录的第二部分是相同的，所以从进程的角度来看，每个进程有4G字节的虚拟空间， 较低的3G字节是自己的用户空间，最高的1G字节则为与所有进程以及内核共享的系统空间。

4.	现在假设我们有如下一个情景：

在进程A中通过系统调用sethostname(const char *name,seze_t len)设置计算机在网络中的“主机名”.
在该情景中我们势必涉及到从用户空间向内核空间传递数据的问题，name是用户空间中的地址，它要通过系统调用设置到内核中的某个地址中。让我们看看这个 过程中的一些细节问题：系统调用的具体实现是将系统调用的参数依次存入寄存器ebx,ecx,edx,esi,edi（最多5个参数，该情景有两个 name和len），接着将系统调用号存入寄存器eax，然后通过中断指令“int 80”使进程A进入系统空间。由于进程的CPU运行级别小于等于为系统调用设置的陷阱门的准入级别3，所以可以畅通无阻的进入系统空间去执行为int 80设置的函数指针system_call()。由于system_call()属于内核空间，其运行级别DPL为0，CPU要将堆栈切换到内核堆栈，即 进程A的系统空间堆栈。我们知道内核为新建进程创建task_struct结构时，共分配了两个连续的页面，即8K的大小，并将底部约1k的大小用于 task_struct（如#define alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))）,而其余部分内存用于系统空间的堆栈空间，即当从用户空间转入系统空间时，堆栈指针 esp变成了（alloc_task_struct()+8192），这也是为什么系统空间通常用宏定义current（参看其实现）获取当前进程的 task_struct地址的原因。每次在进程从用户空间进入系统空间之初，系统堆栈就已经被依次压入用户堆栈SS、用户堆栈指针ESP、EFLAGS、 用户空间CS、EIP，接着system_call()将eax压入，再接着调用SAVE_ALL依次压入ES、DS、EAX、EBP、EDI、ESI、 EDX、ECX、EBX，然后调用sys_call_table+4*%EAX，本情景为sys_sethostname()。

5.	在sys_sethostname()中，经过一些保护考虑后，调用copy_from_user(to,from,n），其中to指向内核空间 system_utsname.nodename，譬如0xE625A000，from指向用户空间譬如0x8010FE00。现在进程A进入了内核，在 系统空间中运行，MMU根据其PGD将虚拟地址完成到物理地址的映射，最终完成从用户空间到系统空间数据的复制。准备复制之前内核先要确定用户空间地址和 长度的合法性，至于从该用户空间地址开始的某个长度的整个区间是否已经映射并不去检查，如果区间内某个地址未映射或读写权限等问题出现时，则视为坏地址， 就产生一个页面异常，让页面异常服务程序处理。过程如 下：copy_from_user()->generic_copy_from_user()->access_ok()+__copy_user_zeroing().


#7	小结
-------

*	进程寻址空间0~4G

*	进程在用户态只能访问0~3G，只有进入内核态才能访问3G~4G

*	进程通过系统调用进入内核态

*	每个进程虚拟空间的3G~4G部分是相同的

*	进程从用户态进入内核态不会引起CR3的改变但会引起堆栈的改变

Linux 简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0～4G。Linux内核将这4G字节的空间分为两部分。将最高的 1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统 内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。

Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。从图中可以看出（这里无法表示图），每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。

##7.1	虚拟内核空间到物理空间的映射
-------

 内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。读者会问，系 统启动时，内核的代码和数据不是被装入到物理内存吗？它们为什么也处于虚拟内存中呢？这和编译程序有关，后面我们通过具体讨论就会明白这一点。
虽 然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址（0x00000000）开始。对内核空间来说，其地址映射是很简单 的线性映射，0xC0000000就是物理地址与线性地址之间的位移量，在Linux代码中就叫做PAGE_OFFSET。


我们来看一下在include/asm/i386/page.h中对内核空间中地址映射的说明及定义：

```cpp
/*
* This handles the memory map.. We could make this a config
* option, but too many people screw it up, and too few need
* it.
*
* A __PAGE_OFFSET of 0xC0000000 means that the kernel has
* a virtual address space of one gigabyte, which limits the
* amount of physical memory you can use to about 950MB. 
*
* If you want more physical memory than this then see the CONFIG_HIGHMEM4G
* and CONFIG_HIGHMEM64G options in the kernel configuration.
*/

#define __PAGE_OFFSET           (0xC0000000)
……
#define PAGE_OFFSET             ((unsigned long)__PAGE_OFFSET)
#define __pa(x)                 ((unsigned long)(x)-PAGE_OFFSET)
#define __va(x)                 ((void *)((unsigned long)(x)+PAGE_OFFSET))
```

如果你的物理内存大于950MB，那么在编译内核时就需要加CONFIG_HIGHMEM4G和CONFIG_HIGHMEM64G选 项，这种情况我们暂不考虑。如果物理内存小于950MB，则对于内核空间而言，给定一个虚地址x，其物理地址为“x- PAGE_OFFSET”，给定一个物理地址x，其虚地址为“x+ PAGE_OFFSET”。
这里再次说明，宏__pa()仅仅把一个内核空间的虚地址映射到物理地址，而决不适用于用户空间，用户空间的地址映射要复杂得多。

##7.2	内核映像
-------

在下面的描述中，我们把内核的代码和数据就叫内核映像（kernel image）。当系统启动时，Linux内核映像被安装在物理地址0x00100000开始的地方，即1MB开始的区间(第1M留作它用)。然而，在正常 运行时， 整个内核映像应该在虚拟内核空间中，因此，连接程序在连接内核映像时，在所有的符号地址上加一个偏移量PAGE_OFFSET，这样，内核映像在内核空间 的起始地址就为0xC0100000。
例如，进程的页目录PGD（属于内核数据结构）就处于内核空间中。在进程切换时，要将寄存器CR3设置成指 向新进程的页目录PGD，而该目录的起始地址在内核空间中是虚地址，但CR3所需要的是物理地址，这时候就要用__pa()进行地址转换。在 mm_context.h中就有这么一行语句：
asm volatile(“movl %0,%%cr3”: :”r” (__pa(next-&gt;pgd));
这是一行嵌入式汇编代码，其含义是将下一个进程的页目录起始地址next_pgd，通过__pa()转换成物理地址，存放在某个寄存器中，然后用mov指令将其写入CR3寄存器中。经过这行语句的处理，CR3就指向新进程next的页目录表PGD了。



##7.3	高端内存映射方式：
-------

高端内存映射有三种方式：

1.	映射到“内核动态映射空间”

这种方式很简单，因为通过 vmalloc() ，在“内核动态映射空间”申请内存的时候，就可能从高端内存获得页面（参看 vmalloc 的实现），因此说高端内存有可能映射到“内核动态映射空间” 中。

2.	永久内核映射

如果是通过 alloc_page() 获得了高端内存对应的 page，如何给它找个线性空间？

内核专门为此留出一块线性空间，从 PKMAP_BASE 到 FIXADDR_START ，用于映射高端内存。在 2.4 内核上，这个地址范围是 4G-8M 到 4G-4M 之间。这个空间起叫“内核永久映射空间”或者“永久内核映射空间”

这个空间和其它空间使用同样的页目录表，对于内核来说，就是 swapper_pg_dir，对普通进程来说，通过 CR3 寄存器指向。

通常情况下，这个空间是 4M 大小，因此仅仅需要一个页表即可，内核通过来 pkmap_page_table 寻找这个页表。

通过 kmap()， 可以把一个 page 映射到这个空间来

由于这个空间是 4M 大小，最多能同时映射 1024 个 page。因此，对于不使用的的 page，应该及时从这个空间释放掉（也除映射关就是解系），通过 kunmap() ，可以把一个 page 对应的线性地址从这个空间释放出来。

3.	临时映射

内核在 FIXADDR_START 到 FIXADDR_TOP 之间保留了一些线性空间用于特殊需求。这个空间称为“固定映射空间”

这个空间中，有一部分用于高端内存的临时映射。

这块空间具有如下特点：

1.	每个 CPU 占用一块空间

2.	在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个 page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的 km_type 中。

当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。

通过 kmap_atomic() 可实现临时映射。

      下图简单简单表达如何对高端内存进行映射

 !对高端内存进行映射[](../images/kmap_atomic.gif)


Linux内存线性地址空间大小为4GB，分为2个部分：用户空间部分（通常是3G）和内核空间部分（通常是1G）。在此我们主要关注内核地址空间部分。
内核通过内核页全局目录来管理所有的物理内存，由于线性地址前3G空间为用户使用，内核页全局目录前768项（刚好3G）除0、1两项外全部为0，后256项（1G）用来管理所有的物理内存。内核页全局目录在编译时静态地定义为swapper_pg_dir数组，该数组从物理内存地址0x101000处开始存放。



由图可见，内核线性地址空间部分从PAGE_OFFSET（通常定义为3G）开始，为了将内核装入内存，从PAGE_OFFSET开始8M线性地址用来映射内核所在的物理内存地址（也可以说是内核所在虚拟地址是从PAGE_OFFSET开始的）；接下来是mem_map数组，mem_map的起始线性地址与体系结构相关，比如对于UMA结构，由于从PAGE_OFFSET开始16M线性地址空间对应的16M物理地址空间是DMA区，mem_map数组通常开始于PAGE_OFFSET+16M的线性地址；从PAGE_OFFSET开始到VMALLOC_START – VMALLOC_OFFSET的线性地址空间直接映射到物理内存空间（一一对应影射，物理地址<==>线性地址-PAGE_OFFSET），这段区域的大小和机器实际拥有的物理内存大小有关，这儿VMALLOC_OFFSET在X86上为8M，主要用来防止越界错误；在内存比较小的系统上，余下的线性地址空间（还要再减去空白区即VMALLOC_OFFSET）被vmalloc()函数用来把不连续的物理地址空间映射到连续的线性地址空间上，在内存比较大的系统上，vmalloc()使用从VMALLOC_START到VMALLOC_END（也即PKMAP_BASE减去2页的空白页大小PAGE_SIZE（解释VMALLOC_END））的线性地址空间，此时余下的线性地址空间（还要再减去2页的空白区即VMALLOC_OFFSET）又可以分成2部分：第一部分从PKMAP_BASE到FIXADDR_START用来由kmap()函数来建立永久映射高端内存；第二部分，从FIXADDR_START到FIXADDR_TOP，这是一个固定大小的临时映射线性地址空间，（引用：Fixed virtual addresses are needed for subsystems that need to know the virtual address at compile time such as the APIC），在X86体系结构上，FIXADDR_TOP被静态定义为0xFFFFE000,此时这个固定大小空间结束于整个线性地址空间最后4K前面，该固定大小空间大小是在编译时计算出来并存储在__FIXADDR_SIZE变量中。

正是由于vmalloc()使用区、kmap()使用区及固定大小区（kmap_atomic()使用区）的存在才使ZONE_NORMAL区大小受到限制，由于内核在运行时需要这些函数，因此在线性地址空间中至少要VMALLOC_RESERVE大小的空间。VMALLOC_RESERVE的大小与体系结构相关，在X86上，VMALLOC_RESERVE定义为128M，这就是为什么ZONE_NORMAL大小通常是16M到896M的原因。


